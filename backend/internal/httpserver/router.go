package httpserver

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"runtime/debug"
	"strconv"
	"strings"
	"time"

	cedar "github.com/cedar-policy/cedar-go"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	httpSwagger "github.com/swaggo/http-swagger"

	_ "cedar/docs" // Docs generated by Swag CLI
	"cedar/internal/authz"
	"cedar/internal/config"
	"cedar/internal/entra"
	"cedar/internal/simulation"
	"cedar/internal/storage"
)

type CacheInvalidator interface {
	InvalidateApp(ctx context.Context, appID int64) error
}

type healthResponse struct {
	Status       string                 `json:"status"`
	CedarVersion string                 `json:"cedar_version,omitempty"`
	Checks       map[string]healthCheck `json:"checks,omitempty"`
}

type healthCheck struct {
	Status  string `json:"status"`
	Latency string `json:"latency,omitempty"`
	Error   string `json:"error,omitempty"`
}

type clusterStatusResponse struct {
	InstanceID   string                 `json:"instance_id"`
	Status       string                 `json:"status"`
	Uptime       string                 `json:"uptime"`
	CedarVersion string                 `json:"cedar_version"`
	Checks       map[string]healthCheck `json:"checks"`
	Cache        *cacheStats            `json:"cache,omitempty"`
	SSEClients   int                    `json:"sse_clients"`
	StartedAt    string                 `json:"started_at"`
}

type cacheStats struct {
	Enabled   bool   `json:"enabled"`
	L1Size    int    `json:"l1_size,omitempty"`
	L2Enabled bool   `json:"l2_enabled"`
	HitRate   string `json:"hit_rate,omitempty"`
}

type authorizeRequest struct {
	ApplicationID int64           `json:"application_id"`
	Principal     entityReference `json:"principal"`
	Action        entityReference `json:"action"`
	Resource      entityReference `json:"resource"`
	Context       map[string]any  `json:"context,omitempty"`
}

type entityReference struct {
	Type string `json:"type"`
	ID   string `json:"id"`
}

type authorizeResponse struct {
	Decision string   `json:"decision"`
	Reasons  []string `json:"reasons"`
	Errors   []string `json:"errors"`
}

type createAppRequest struct {
	Name             string `json:"name"`
	NamespaceID      int64  `json:"namespace_id"`
	Description      string `json:"description"`
	ApprovalRequired *bool  `json:"approval_required"`
}

type createNamespaceRequest struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

type createPolicyRequest struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	PolicyText  string `json:"policy_text"`
	Activate    bool   `json:"activate"`
}

type upsertEntityRequest struct {
	Type       string              `json:"type"`
	ID         string              `json:"id"`
	Attributes json.RawMessage     `json:"attributes" swaggertype:"object"`
	Parents    []storage.ParentRef `json:"parents"`
}

type createSchemaRequest struct {
	SchemaText string `json:"schema_text"`
	Activate   bool   `json:"activate"`
}

type activateSchemaRequest struct {
	Version int `json:"version"`
}

type auditListResponse struct {
	Items []storage.AuditLog `json:"items"`
	Total int                `json:"total"`
}

// entitlementsRequest is the request body for IdP entitlements lookup.
// An IdP (Identity Provider) can call this endpoint to get all entitlements
// for a user and their groups within an application.
type entitlementsRequest struct {
	// ApplicationID is the Cedar application to query
	ApplicationID int64 `json:"application_id"`
	// ApplicationName can be used instead of ApplicationID
	ApplicationName string `json:"application_name,omitempty"`
	// Username is the principal user ID (e.g., "alice", "jsmith")
	Username string `json:"username"`
	// Groups is an optional list of group IDs the user belongs to
	Groups []string `json:"groups,omitempty"`
	// IncludeInherited includes permissions inherited from group memberships
	IncludeInherited bool `json:"include_inherited,omitempty"`
}

// entitlementsResponse contains the entitlements for a user.
type entitlementsResponse struct {
	// Username is the queried principal
	Username string `json:"username"`
	// ApplicationID is the resolved application ID
	ApplicationID int64 `json:"application_id"`
	// ApplicationName is the application name
	ApplicationName string `json:"application_name"`
	// Entitlements are the permissions granted to this user
	Entitlements []entitlementEntry `json:"entitlements"`
	// GroupEntitlements are permissions inherited from groups
	GroupEntitlements map[string][]entitlementEntry `json:"group_entitlements,omitempty"`
}

// entitlementEntry represents a single entitlement/permission.
type entitlementEntry struct {
	Effect        string   `json:"effect"`
	Actions       []string `json:"actions"`
	ResourceTypes []string `json:"resource_types"`
	ResourceIDs   []string `json:"resource_ids,omitempty"`
	Conditions    string   `json:"conditions,omitempty"`
}

// AuditLogger is used to record audit events.
type AuditLogger interface {
	Log(ctx context.Context, applicationID *int64, actor, action, target, decision string, auditContext map[string]any) error
}

// SchemaProvider is used to validate policies against schemas.
type SchemaProvider interface {
	GetActiveSchema(ctx context.Context, applicationID int64) (*storage.Schema, error)
}

// API provides the HTTP handlers for the application.
type API struct {
	cfg                 config.Config
	authzSvc            *authz.Service
	apps                *storage.ApplicationRepo
	policies            *storage.PolicyRepo
	entities            *storage.EntityRepo
	schemas             *storage.SchemaRepo
	audits              *storage.AuditRepo
	namespaces          *storage.NamespaceRepo
	settings            *storage.SettingsRepo
	backendAuthRepo     *storage.BackendAuthRepo
	backendInstanceRepo *storage.BackendInstanceRepo
	cache               CacheInvalidator
	cacheStore          *storage.Cache // For health checks
	sseBroker           *SSEBroker
	entraClient         *entra.Client
	db                  DBPinger // For health checks
	instanceRegistry    *storage.InstanceRegistry
	instanceID          string
	startedAt           time.Time
}

// DBPinger interface for database health checks
type DBPinger interface {
	PingContext(ctx context.Context) error
}

// NewRouter configures the HTTP router with basic endpoints.
// @title Enterprise Policy Management API
// @version 1.0
// @description API for managing Cedar policies, entities, and performing authorization checks.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.email support@example.com
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /
// @schemes http https
// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name X-API-Key
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func NewRouter(cfg config.Config, authzSvc *authz.Service, apps *storage.ApplicationRepo, policies *storage.PolicyRepo, entities *storage.EntityRepo, schemas *storage.SchemaRepo, audits *storage.AuditRepo, namespaces *storage.NamespaceRepo, settings *storage.SettingsRepo, backendAuthRepo *storage.BackendAuthRepo, backendInstanceRepo *storage.BackendInstanceRepo, cache CacheInvalidator, cacheStore *storage.Cache, db DBPinger, instanceRegistry *storage.InstanceRegistry, simulationSvc *simulation.Service) http.Handler {
	// Create SSE broker for real-time event streaming
	sseBroker := NewSSEBroker()

	// Create Entra client for Microsoft Graph API integration
	// First check database settings, then fall back to environment config
	var entraClient *entra.Client
	if settings != nil {
		ctx := context.Background()
		if dbConfig, err := settings.GetEntraConfig(ctx); err == nil && dbConfig.Configured {
			entraClient = entra.NewClient(dbConfig.TenantID, dbConfig.ClientID, dbConfig.ClientSecret)
		}
	}
	// Fall back to environment config if no database settings
	if entraClient == nil || !entraClient.IsConfigured() {
		entraClient = entra.NewClient(cfg.AzureTenantID, cfg.AzureClientID, cfg.AzureClientSecret)
	}

	// Get instance ID from registry if available, otherwise generate one
	var instanceID string
	if instanceRegistry != nil {
		instanceID = instanceRegistry.GetInstanceID()
	} else {
		// Generate instance ID from hostname + random suffix
		hostname, _ := os.Hostname()
		instanceID = fmt.Sprintf("%s-%d", hostname, time.Now().UnixNano()%10000)
	}
	startedAt := time.Now()

	api := &API{
		cfg:                 cfg,
		authzSvc:            authzSvc,
		apps:                apps,
		policies:            policies,
		entities:            entities,
		schemas:             schemas,
		audits:              audits,
		namespaces:          namespaces,
		settings:            settings,
		backendAuthRepo:     backendAuthRepo,
		backendInstanceRepo: backendInstanceRepo,
		cache:               cache,
		cacheStore:          cacheStore,
		sseBroker:           sseBroker,
		entraClient:         entraClient,
		db:                  db,
		instanceRegistry:    instanceRegistry,
		instanceID:          instanceID,
		startedAt:           startedAt,
	}

	// Set up status function for instance registry if available
	if instanceRegistry != nil {
		instanceRegistry.SetStatusFunc(api.getInstanceStatus)
	}

	r := chi.NewRouter()
	r.Use(corsMiddleware(cfg))
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Timeout(60 * time.Second))

	// Initialize auth middleware
	authMiddleware, err := NewAuthMiddleware(cfg)
	if err != nil {
		panic("failed to create auth middleware: " + err.Error())
	}
	r.Use(authMiddleware.Middleware)

	// Initialize rate limiter (must be after auth middleware to access user context)
	if rateLimiter := NewRateLimiter(cfg); rateLimiter != nil {
		r.Use(rateLimiter)
	}

	r.Get("/health", api.handleHealth)
	r.Get("/v1/cluster/status", api.handleClusterStatus)
	r.Get("/v1/cluster/instances", api.handleListInstances)
	r.Get("/v1/cluster/live-backends", api.handleListLiveBackends)
	r.Get("/v1/me", api.handleGetMe)
	r.Post("/v1/authorize", api.handleAuthorize)

	r.Route("/v1/apps", func(r chi.Router) {
		r.Get("/", api.handleListApps)
		r.Post("/", api.handleCreateApp)
	})

	r.Route("/v1/namespaces", func(r chi.Router) {
		r.Get("/", api.handleListNamespaces)
		r.Post("/", api.handleCreateNamespace)
	})

	r.Post("/v1/apps/{id}/policies", api.handleCreatePolicy)
	r.Get("/v1/apps/{id}/policies", api.handleListPolicies)
	r.Get("/v1/apps/{id}/policies/{policyId}", api.handleGetPolicy)
	r.Post("/v1/apps/{id}/policies/{policyId}/versions/{version}/approve", api.handleApprovePolicy)
	r.Post("/v1/apps/{id}/policies/{policyId}/versions/{version}/activate", api.handleActivatePolicy)
	r.Delete("/v1/apps/{id}/policies/{policyId}", api.handleDeletePolicy)
	r.Post("/v1/apps/{id}/policies/{policyId}/approve-delete", api.handleApproveDeletePolicy)

	r.Post("/v1/apps/{id}/entities", api.handleUpsertEntity)
	r.Get("/v1/apps/{id}/entities", api.handleListEntities)

	r.Route("/v1/apps/{id}/schemas", func(r chi.Router) {
		r.Get("/", api.handleListSchemas)
		r.Post("/", api.handleCreateSchema)
		r.Get("/active", api.handleGetActiveSchema)
		r.Post("/activate", api.handleActivateSchema)
	})

	r.Get("/v1/apps/{id}/permissions", api.handleListPermissions)

	// IdP Integration: Get entitlements for a user/groups
	r.Post("/v1/entitlements", api.handleGetEntitlements)

	// SSE: Real-time policy update events
	r.Get("/v1/events", api.handleSSEEvents)

	// Entra ID (Azure AD) integration for user/group lookup
	r.Route("/v1/entra", func(r chi.Router) {
		r.Get("/status", api.handleEntraStatus)
		r.Get("/users", api.handleEntraSearchUsers)
		r.Get("/users/{id}", api.handleEntraGetUser)
		r.Get("/groups", api.handleEntraSearchGroups)
		r.Get("/groups/{id}", api.handleEntraGetGroup)
	})

	// Settings management
	r.Route("/v1/settings", func(r chi.Router) {
		r.Get("/entra", api.handleGetEntraSettings)
		r.Post("/entra", api.handleSaveEntraSettings)
		r.Post("/entra/test", api.handleTestEntraConnection)
		r.Delete("/entra", api.handleDeleteEntraSettings)

		// Backend authentication settings
		r.Get("/backend-auth", api.handleGetBackendAuthConfig)
		r.Put("/backend-auth", api.handleUpdateBackendAuthConfig)
		r.Post("/backend-auth/ca", api.handleUploadCACertificate)
		r.Delete("/backend-auth/ca", api.handleRemoveCACertificate)
	})

	// Backend authentication verification (for backends to verify their credentials)
	r.Post("/v1/cluster/verify", api.handleVerifyBackendAuth)

	// Backend instance management
	r.Route("/v1/cluster/backends", func(r chi.Router) {
		r.Post("/register", api.handleRegisterBackendInstance)
		r.Get("/", api.handleListBackendInstances)
		r.Get("/pending", api.handleListPendingBackendInstances)
		r.Get("/{instanceId}", api.handleGetBackendInstanceStatus)
		r.Post("/{instanceId}/approve", api.handleApproveBackendInstance)
		r.Post("/{instanceId}/reject", api.handleRejectBackendInstance)
		r.Post("/{instanceId}/suspend", api.handleSuspendBackendInstance)
		r.Post("/{instanceId}/unsuspend", api.handleUnsuspendBackendInstance)
		r.Delete("/{instanceId}", api.handleDeleteBackendInstance)
	})

	// Update approval_required setting
	r.Put("/v1/settings/backend-auth/approval", api.handleUpdateApprovalRequired)

	// Public auth config endpoint (no auth required for this one)
	r.Get("/v1/auth/config", api.handleGetAuthConfig)

	r.Route("/v1/audit", func(r chi.Router) {
		r.Get("/", api.handleListAuditLogs)
	})

	// Simulation routes
	if simulationSvc != nil {
		simAPI := NewSimulationAPI(simulationSvc)
		RegisterSimulationRoutes(r, simAPI)
	}

	// Swagger UI
	r.Get("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // The url pointing to API definition
	))

	return r
}

// @Summary Health Check
// @Description Checks if the service is running
// @Tags System
// @Produce json
// @Success 200 {object} healthResponse
// @Router /health [get]
func (a *API) handleHealth(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

	version := "unknown"
	if info, ok := debug.ReadBuildInfo(); ok {
		for _, dep := range info.Deps {
			if dep.Path == "github.com/cedar-policy/cedar-go" {
				version = dep.Version
				break
			}
		}
	}

	// Perform health checks
	checks := make(map[string]healthCheck)
	overallStatus := "healthy"

	// Check database
	if a.db != nil {
		start := time.Now()
		if err := a.db.PingContext(r.Context()); err != nil {
			overallStatus = "degraded"
			checks["database"] = healthCheck{
				Status: "error",
				Error:  err.Error(),
			}
		} else {
			checks["database"] = healthCheck{
				Status:  "healthy",
				Latency: time.Since(start).String(),
			}
		}
	}

	// Check Redis via cache store
	if a.cacheStore != nil {
		start := time.Now()
		if err := a.cacheStore.Ping(r.Context()); err != nil {
			// Redis down is degraded, not critical
			if overallStatus == "healthy" {
				overallStatus = "degraded"
			}
			checks["redis"] = healthCheck{
				Status: "error",
				Error:  err.Error(),
			}
		} else {
			checks["redis"] = healthCheck{
				Status:  "healthy",
				Latency: time.Since(start).String(),
			}
		}
	}

	resp := healthResponse{
		Status:       overallStatus,
		CedarVersion: version,
		Checks:       checks,
	}

	if overallStatus != "healthy" {
		w.WriteHeader(http.StatusServiceUnavailable)
	}

	_ = json.NewEncoder(w).Encode(resp)
}

// @Summary Get Cluster Status
// @Description Returns detailed status of this backend instance including health checks and cache stats
// @Tags System
// @Produce json
// @Success 200 {object} clusterStatusResponse
// @Router /v1/cluster/status [get]
func (a *API) handleClusterStatus(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	version := "unknown"
	if info, ok := debug.ReadBuildInfo(); ok {
		for _, dep := range info.Deps {
			if dep.Path == "github.com/cedar-policy/cedar-go" {
				version = dep.Version
				break
			}
		}
	}

	// Perform health checks
	checks := make(map[string]healthCheck)
	overallStatus := "healthy"

	// Check database
	if a.db != nil {
		start := time.Now()
		if err := a.db.PingContext(r.Context()); err != nil {
			overallStatus = "degraded"
			checks["database"] = healthCheck{
				Status: "error",
				Error:  err.Error(),
			}
		} else {
			checks["database"] = healthCheck{
				Status:  "healthy",
				Latency: time.Since(start).String(),
			}
		}
	}

	// Check Redis via cache store
	if a.cacheStore != nil {
		start := time.Now()
		if err := a.cacheStore.Ping(r.Context()); err != nil {
			if overallStatus == "healthy" {
				overallStatus = "degraded"
			}
			checks["redis"] = healthCheck{
				Status: "error",
				Error:  err.Error(),
			}
		} else {
			checks["redis"] = healthCheck{
				Status:  "healthy",
				Latency: time.Since(start).String(),
			}
		}
	}

	// Get cache stats
	var cacheStatsResp *cacheStats
	if a.cacheStore != nil {
		stats := a.cacheStore.Stats()
		cacheStatsResp = &cacheStats{
			Enabled:   true,
			L1Size:    stats.L1Size,
			L2Enabled: stats.L2Enabled,
			HitRate:   fmt.Sprintf("%.1f%%", stats.HitRate*100),
		}
	}

	// Get SSE client count
	sseClients := 0
	if a.sseBroker != nil {
		sseClients = a.sseBroker.ClientCount()
	}

	// Calculate uptime
	uptime := time.Since(a.startedAt)
	uptimeStr := formatDuration(uptime)

	resp := clusterStatusResponse{
		InstanceID:   a.instanceID,
		Status:       overallStatus,
		Uptime:       uptimeStr,
		CedarVersion: version,
		Checks:       checks,
		Cache:        cacheStatsResp,
		SSEClients:   sseClients,
		StartedAt:    a.startedAt.UTC().Format(time.RFC3339),
	}

	_ = json.NewEncoder(w).Encode(resp)
}

// formatDuration formats a duration into a human-readable string
func formatDuration(d time.Duration) string {
	d = d.Round(time.Second)
	h := d / time.Hour
	d -= h * time.Hour
	m := d / time.Minute
	d -= m * time.Minute
	s := d / time.Second

	if h > 0 {
		return fmt.Sprintf("%dh %dm %ds", h, m, s)
	}
	if m > 0 {
		return fmt.Sprintf("%dm %ds", m, s)
	}
	return fmt.Sprintf("%ds", s)
}

// getInstanceStatus returns the current instance status for the instance registry
func (a *API) getInstanceStatus() storage.InstanceInfo {
	version := "unknown"
	if info, ok := debug.ReadBuildInfo(); ok {
		for _, dep := range info.Deps {
			if dep.Path == "github.com/cedar-policy/cedar-go" {
				version = dep.Version
				break
			}
		}
	}

	// Perform health checks
	checks := make(map[string]storage.HealthStatus)
	overallStatus := "healthy"
	ctx := context.Background()

	// Check database
	if a.db != nil {
		start := time.Now()
		if err := a.db.PingContext(ctx); err != nil {
			overallStatus = "degraded"
			checks["database"] = storage.HealthStatus{
				Status: "error",
				Error:  err.Error(),
			}
		} else {
			checks["database"] = storage.HealthStatus{
				Status:  "healthy",
				Latency: time.Since(start).String(),
			}
		}
	}

	// Check Redis via cache store
	if a.cacheStore != nil {
		start := time.Now()
		if err := a.cacheStore.Ping(ctx); err != nil {
			if overallStatus == "healthy" {
				overallStatus = "degraded"
			}
			checks["redis"] = storage.HealthStatus{
				Status: "error",
				Error:  err.Error(),
			}
		} else {
			checks["redis"] = storage.HealthStatus{
				Status:  "healthy",
				Latency: time.Since(start).String(),
			}
		}
	}

	// Get cache stats
	var cacheStatus *storage.CacheStatus
	if a.cacheStore != nil {
		stats := a.cacheStore.Stats()
		cacheStatus = &storage.CacheStatus{
			Enabled:   true,
			L1Size:    stats.L1Size,
			L2Enabled: stats.L2Enabled,
			HitRate:   fmt.Sprintf("%.1f%%", stats.HitRate*100),
		}
	}

	// Get SSE client count
	sseClients := 0
	if a.sseBroker != nil {
		sseClients = a.sseBroker.ClientCount()
	}

	return storage.InstanceInfo{
		InstanceID:   a.instanceID,
		Status:       overallStatus,
		Uptime:       formatDuration(time.Since(a.startedAt)),
		CedarVersion: version,
		StartedAt:    a.startedAt,
		Checks:       checks,
		Cache:        cacheStatus,
		SSEClients:   sseClients,
	}
}

// @Summary List All Instances
// @Description Returns status of all registered backend instances in the cluster
// @Tags System
// @Produce json
// @Success 200 {object} listInstancesResponse
// @Router /v1/cluster/instances [get]
func (a *API) handleListInstances(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	var instances []storage.InstanceInfo

	if a.instanceRegistry != nil {
		var err error
		instances, err = a.instanceRegistry.ListInstances(r.Context())
		if err != nil {
			// Fallback to just this instance
			instances = []storage.InstanceInfo{a.getInstanceStatus()}
		}

		// Filter to only show approved instances (if backend approval is enabled)
		if a.backendInstanceRepo != nil {
			approvedStatus := storage.BackendStatusApproved
			approvedList, err := a.backendInstanceRepo.List(r.Context(), &approvedStatus)
			if err == nil {
				// Build a map of approved instance IDs
				approvedInstanceIDs := make(map[string]bool)
				for _, inst := range approvedList {
					approvedInstanceIDs[inst.InstanceID] = true
				}

				// Filter instances to only approved ones
				filteredInstances := make([]storage.InstanceInfo, 0)
				for _, inst := range instances {
					if approvedInstanceIDs[inst.InstanceID] {
						filteredInstances = append(filteredInstances, inst)
					}
				}
				instances = filteredInstances
			}
		}
	} else {
		// No registry, return just this instance
		instances = []storage.InstanceInfo{a.getInstanceStatus()}
	}

	resp := listInstancesResponse{
		Instances: instances,
		Total:     len(instances),
	}

	_ = json.NewEncoder(w).Encode(resp)
}

// listInstancesResponse is the response for the list instances endpoint
type listInstancesResponse struct {
	Instances []storage.InstanceInfo `json:"instances"`
	Total     int                    `json:"total"`
}

// handleListLiveBackends returns a plain-text list of approved, healthy backend servers
// for Nginx dynamic upstream configuration. Only returns backends that are:
// 1. Approved in the database
// 2. Have sent a heartbeat within the last 35 seconds
// @Summary List Live Backends for Load Balancer
// @Description Returns plain text list of live backend servers for Nginx upstream configuration
// @Tags System
// @Produce text/plain
// @Success 200 {string} string "List of server directives"
// @Router /v1/cluster/live-backends [get]
func (a *API) handleListLiveBackends(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/plain")

	if a.backendInstanceRepo == nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte("# Backend instance repository not configured\n"))
		return
	}

	// Get all approved backends from the database
	approvedStatus := storage.BackendStatusApproved
	approvedList, err := a.backendInstanceRepo.List(r.Context(), &approvedStatus)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		w.Write([]byte(fmt.Sprintf("# Error fetching backends: %v\n", err)))
		return
	}

	var response strings.Builder
	response.WriteString("# Auto-generated by Cedar - do not edit manually\n")
	response.WriteString(fmt.Sprintf("# Generated at: %s\n", time.Now().Format(time.RFC3339)))

	liveCount := 0
	for _, inst := range approvedList {
		// Check if the instance is stale (heartbeat older than 35s)
		isStale := true
		if inst.LastHeartbeat != nil {
			isStale = time.Since(*inst.LastHeartbeat) > 35*time.Second
		}
		if !isStale {
			// Use the hostname (container ID) which Docker DNS can resolve
			response.WriteString(fmt.Sprintf("server %s:8080;\n", inst.Hostname))
			liveCount++
		}
	}

	// If no live backends, add a comment but don't fail
	if liveCount == 0 {
		response.WriteString("# No live backends available\n")
		// Add a placeholder that will cause Nginx to fail gracefully
		// This prevents Nginx from crashing when the upstream is empty
		response.WriteString("server 127.0.0.1:1 down;\n")
	}

	response.WriteString(fmt.Sprintf("# Total live backends: %d\n", liveCount))

	w.WriteHeader(http.StatusOK)
	w.Write([]byte(response.String()))
}

// @Summary Get Current User
// @Description Returns the currently authenticated user
// @Tags System
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {object} UserContext
// @Failure 401 {object} map[string]string
// @Router /v1/me [get]
func (a *API) handleGetMe(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		user := GetUserFromContext(r.Context())
		if user == nil {
			w.WriteHeader(http.StatusUnauthorized)
			_ = json.NewEncoder(w).Encode(map[string]string{"error": "not authenticated"})
			return
		}
		_ = json.NewEncoder(w).Encode(user)
}

// @Summary Evaluate Authorization
// @Description Performs a Cedar authorization check
// @Tags Authorization
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body authorizeRequest true "Authorization Request"
// @Success 200 {object} authorizeResponse
// @Failure 400 {object} map[string]string
// @Router /v1/authorize [post]
func (a *API) handleAuthorize(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		var req authorizeRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
			return
		}

		if req.ApplicationID == 0 || req.Principal.Type == "" || req.Action.Type == "" || req.Resource.Type == "" || req.Principal.ID == "" || req.Action.ID == "" || req.Resource.ID == "" {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "application_id, principal, action, and resource are required"})
			return
		}

	// Prepare context with cache source tracker
	var cacheSource string = "DB" // Default if not updated
	ctx := context.WithValue(r.Context(), storage.CtxKeyCacheSource, &cacheSource)

	result, err := a.authzSvc.Evaluate(ctx, authz.EvaluateInput{
			ApplicationID: req.ApplicationID,
			Principal:     authz.Reference{Type: req.Principal.Type, ID: req.Principal.ID},
			Action:        authz.Reference{Type: req.Action.Type, ID: req.Action.ID},
			Resource:      authz.Reference{Type: req.Resource.Type, ID: req.Resource.ID},
			Context:       req.Context,
		})
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}

	// Set response header to indicate cache source (L1, L2, or DB)
	w.Header().Set("X-Cedar-Cache", cacheSource)

		// Log authorization decision to audit trail
	if a.audits != nil {
			appID := req.ApplicationID
			principal := req.Principal.Type + "::" + req.Principal.ID
			action := req.Action.Type + "::" + req.Action.ID
			resource := req.Resource.Type + "::" + req.Resource.ID

		// Get the authenticated caller (service/user making the request)
		caller := "unknown"
		if user := GetUserFromContext(r.Context()); user != nil {
			caller = user.ID
		}

			auditCtx := map[string]any{
			"caller":    caller,    // Authenticated service/user making the request
			"principal": principal, // Subject of the authorization check
				"action":    action,
				"resource":  resource,
				"reasons":   result.Reasons,
				"errors":    result.Errors,
			}
			if req.Context != nil {
				auditCtx["request_context"] = req.Context
			}
		// Actor is the authenticated caller, not the principal being checked
		_ = a.audits.Log(r.Context(), &appID, caller, "authorize", resource, result.Decision, auditCtx)
		}

		w.WriteHeader(http.StatusOK)
		json.NewEncoder(w).Encode(authorizeResponse{
			Decision: result.Decision,
			Reasons:  result.Reasons,
			Errors:   result.Errors,
		})
}

// @Summary List Applications
// @Description Returns a list of all registered applications
// @Tags Applications
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {array} storage.Application
// @Failure 500 {object} map[string]string
// @Router /v1/apps [get]
func (a *API) handleListApps(w http.ResponseWriter, r *http.Request) {
	appsList, err := a.apps.List(r.Context())
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}
			json.NewEncoder(w).Encode(appsList)
}

// @Summary Create Application
// @Description Registers a new application
// @Tags Applications
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body createAppRequest true "Application Details"
// @Success 200 {object} map[string]int64
// @Failure 400 {object} map[string]string
// @Router /v1/apps [post]
func (a *API) handleCreateApp(w http.ResponseWriter, r *http.Request) {
			var req createAppRequest
			if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
				return
			}
			if req.Name == "" || req.NamespaceID == 0 {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "name and namespace_id are required"})
				return
			}

	approvalRequired := true
	if req.ApprovalRequired != nil {
		approvalRequired = *req.ApprovalRequired
	}

	id, err := a.apps.Create(r.Context(), req.Name, req.NamespaceID, req.Description, approvalRequired)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}

			// Log application creation to audit trail
	if a.audits != nil {
				auditCtx := map[string]any{
			"name":              req.Name,
			"namespace_id":      req.NamespaceID,
			"description":       req.Description,
			"approval_required": approvalRequired,
				}
		_ = a.audits.Log(r.Context(), &id, "api", "application.create", req.Name, "", auditCtx)
			}

			json.NewEncoder(w).Encode(map[string]any{"id": id})
}

// @Summary List Namespaces
// @Description Returns a list of all namespaces
// @Tags Namespaces
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {array} storage.Namespace
// @Failure 500 {object} map[string]string
// @Router /v1/namespaces [get]
func (a *API) handleListNamespaces(w http.ResponseWriter, r *http.Request) {
	list, err := a.namespaces.List(r.Context())
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}
			if list == nil {
				list = []storage.Namespace{}
			}
			json.NewEncoder(w).Encode(list)
}

// @Summary Create Namespace
// @Description Creates a new namespace
// @Tags Namespaces
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body createNamespaceRequest true "Namespace Details"
// @Success 200 {object} map[string]int64
// @Failure 400 {object} map[string]string
// @Router /v1/namespaces [post]
func (a *API) handleCreateNamespace(w http.ResponseWriter, r *http.Request) {
			var req createNamespaceRequest
			if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
				return
			}
			if req.Name == "" {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "name is required"})
				return
			}

	id, err := a.namespaces.Create(r.Context(), req.Name, req.Description)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}

			// Log namespace creation to audit trail
	if a.audits != nil {
				auditCtx := map[string]any{
					"name":        req.Name,
					"description": req.Description,
				}
		_ = a.audits.Log(r.Context(), nil, "api", "namespace.create", req.Name, "", auditCtx)
			}

			json.NewEncoder(w).Encode(map[string]any{"id": id})
}

// @Summary Create/Update Policy
// @Description Creates a new policy version or updates an existing one
// @Tags Policies
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body createPolicyRequest true "Policy Details"
// @Success 200 {object} map[string]any
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/policies [post]
func (a *API) handleCreatePolicy(w http.ResponseWriter, r *http.Request) {
		appID, err := parseIDParam(r, "id")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
			return
		}

		var req createPolicyRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
			return
		}
		if req.Name == "" || req.PolicyText == "" {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "name and policy_text are required"})
			return
		}

		// Validate Cedar syntax early.
		var tmpPolicy cedar.Policy
		if err := tmpPolicy.UnmarshalCedar([]byte(req.PolicyText)); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid cedar policy syntax: " + err.Error()})
			return
		}

		// Check if schema exists for information purposes
		var hasActiveSchema bool
	if a.schemas != nil {
		activeSchema, err := a.schemas.GetActiveSchema(r.Context(), appID)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": "failed to check schema: " + err.Error()})
				return
			}
			hasActiveSchema = activeSchema != nil
		}
	_ = hasActiveSchema

	policyID, version, status, err := a.policies.UpsertPolicyWithVersion(r.Context(), appID, req.Name, req.Description, req.PolicyText, req.Activate)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}
	if a.cache != nil {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Publish SSE event for real-time updates
	if a.sseBroker != nil {
		a.sseBroker.PublishPolicyUpdate(appID, "created")
		}

		// Log policy creation/update to audit trail
	if a.audits != nil {
			auditAction := "policy.create"
			auditCtx := map[string]any{
				"policy_name": req.Name,
				"version":     version,
				"activated":   req.Activate,
			"status":      status,
			}
		_ = a.audits.Log(r.Context(), &appID, "api", auditAction, req.Name, "", auditCtx)
		}

	json.NewEncoder(w).Encode(map[string]any{"policy_id": policyID, "version": version, "status": status})
}

// @Summary List Policies
// @Description Returns a list of policies for an application
// @Tags Policies
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {array} storage.PolicySummary
// @Failure 500 {object} map[string]string
// @Router /v1/apps/{id}/policies [get]
func (a *API) handleListPolicies(w http.ResponseWriter, r *http.Request) {
		appID, err := parseIDParam(r, "id")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
			return
		}

	items, err := a.policies.ListPolicies(r.Context(), appID)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}
		json.NewEncoder(w).Encode(items)
}

// @Summary Get Policy Details
// @Description Returns details of a specific policy
// @Tags Policies
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param policyId path int true "Policy ID"
// @Success 200 {object} storage.PolicyDetails
// @Failure 404 {object} map[string]string
// @Router /v1/apps/{id}/policies/{policyId} [get]
func (a *API) handleGetPolicy(w http.ResponseWriter, r *http.Request) {
		appID, err := parseIDParam(r, "id")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
			return
		}
		policyID, err := parseIDParam(r, "policyId")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid policy id"})
			return
		}

	item, err := a.policies.GetPolicy(r.Context(), appID, policyID)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}
		json.NewEncoder(w).Encode(item)
}

// @Summary Approve Policy Version
// @Description Approves a policy version
// @Tags Policies
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param policyId path int true "Policy ID"
// @Param version path int true "Version"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/policies/{policyId}/versions/{version}/approve [post]
func (a *API) handleApprovePolicy(w http.ResponseWriter, r *http.Request) {
	appID, _ := parseIDParam(r, "id")
	policyID, err := parseIDParam(r, "policyId")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid policy id"})
		return
	}
	version64, err := parseIDParam(r, "version")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid version"})
		return
	}
	version := int(version64)

	user := GetUserFromContext(r.Context())
	approver := "unknown"
	if user != nil {
		approver = user.ID
	}

	if err := a.policies.ApproveVersion(r.Context(), policyID, version, approver); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Audit
	if a.audits != nil {
		auditCtx := map[string]any{
			"version":   version,
			"policy_id": policyID,
		}
		_ = a.audits.Log(r.Context(), &appID, "api", "policy.approve", strconv.FormatInt(policyID, 10), "", auditCtx)
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "approved"})
}

// @Summary Activate Policy Version
// @Description Activates a policy version
// @Tags Policies
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param policyId path int true "Policy ID"
// @Param version path int true "Version"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/policies/{policyId}/versions/{version}/activate [post]
func (a *API) handleActivatePolicy(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}
	policyID, err := parseIDParam(r, "policyId")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid policy id"})
		return
	}
	version64, err := parseIDParam(r, "version")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid version"})
		return
	}
	version := int(version64)

	if err := a.policies.ActivateVersion(r.Context(), appID, policyID, version); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	if a.cache != nil {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Publish SSE event for real-time updates
	if a.sseBroker != nil {
		a.sseBroker.PublishPolicyUpdate(appID, "activated")
	}

	// Audit
	if a.audits != nil {
		auditCtx := map[string]any{
			"version":   version,
			"policy_id": policyID,
		}
		_ = a.audits.Log(r.Context(), &appID, "api", "policy.activate", strconv.FormatInt(policyID, 10), "", auditCtx)
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "active"})
}

// @Summary Delete Policy
// @Description Deletes a policy (or requests deletion)
// @Tags Policies
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param policyId path int true "Policy ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/policies/{policyId} [delete]
func (a *API) handleDeletePolicy(w http.ResponseWriter, r *http.Request) {
	appID, _ := parseIDParam(r, "id")
	policyID, err := parseIDParam(r, "policyId")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid policy id"})
		return
	}

	status, err := a.policies.DeletePolicy(r.Context(), appID, policyID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	if a.cache != nil && status == "deleted" {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Publish SSE event for real-time updates
	if a.sseBroker != nil {
		a.sseBroker.PublishPolicyUpdate(appID, "deleted")
	}

	if a.audits != nil {
		_ = a.audits.Log(r.Context(), &appID, "api", "policy.delete", strconv.FormatInt(policyID, 10), "", map[string]any{"status": status})
	}

	json.NewEncoder(w).Encode(map[string]string{"status": status})
}

// @Summary Approve Policy Deletion
// @Description Approves a pending policy deletion
// @Tags Policies
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param policyId path int true "Policy ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/policies/{policyId}/approve-delete [post]
func (a *API) handleApproveDeletePolicy(w http.ResponseWriter, r *http.Request) {
	appID, _ := parseIDParam(r, "id")
	policyID, err := parseIDParam(r, "policyId")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid policy id"})
		return
	}

	user := GetUserFromContext(r.Context())
	approver := "unknown"
	if user != nil {
		approver = user.ID
	}

	if err := a.policies.ApprovePolicyDeletion(r.Context(), policyID, approver); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	if a.cache != nil {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Publish SSE event for real-time updates
	if a.sseBroker != nil {
		a.sseBroker.PublishPolicyUpdate(appID, "deleted")
	}

	if a.audits != nil {
		_ = a.audits.Log(r.Context(), &appID, "api", "policy.approve_delete", strconv.FormatInt(policyID, 10), "", nil)
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}

// @Summary Upsert Entity
// @Description Creates or updates an entity
// @Tags Entities
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body upsertEntityRequest true "Entity Details"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/entities [post]
func (a *API) handleUpsertEntity(w http.ResponseWriter, r *http.Request) {
		appID, err := parseIDParam(r, "id")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
			return
		}

		var req upsertEntityRequest
		if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
			return
		}
		if req.Type == "" || req.ID == "" {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "type and id are required"})
			return
		}

	if err := a.entities.UpsertEntity(r.Context(), appID, req.Type, req.ID, req.Attributes, req.Parents); err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}
	if a.cache != nil {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Publish SSE event for real-time updates
	if a.sseBroker != nil {
		a.sseBroker.PublishEntityUpdate(appID)
		}

		// Log entity upsert to audit trail
	if a.audits != nil {
			entityRef := req.Type + "::" + req.ID
			auditCtx := map[string]any{
				"entity_type": req.Type,
				"entity_id":   req.ID,
			}
			if len(req.Parents) > 0 {
				auditCtx["parents"] = req.Parents
			}
		_ = a.audits.Log(r.Context(), &appID, "api", "entity.upsert", entityRef, "", auditCtx)
		}

		w.WriteHeader(http.StatusNoContent)
}

// @Summary List Entities
// @Description Returns a list of entities for an application
// @Tags Entities
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]string
// @Router /v1/apps/{id}/entities [get]
func (a *API) handleListEntities(w http.ResponseWriter, r *http.Request) {
		appID, err := parseIDParam(r, "id")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
			return
		}
	entitiesMap, err := a.entities.Entities(r.Context(), appID)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}
		json.NewEncoder(w).Encode(entitiesMap)
}

// @Summary List Schemas
// @Description Returns a list of schema versions
// @Tags Schemas
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {array} storage.Schema
// @Failure 500 {object} map[string]string
// @Router /v1/apps/{id}/schemas [get]
func (a *API) handleListSchemas(w http.ResponseWriter, r *http.Request) {
			appID, err := parseIDParam(r, "id")
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
				return
			}
	items, err := a.schemas.ListSchemas(r.Context(), appID)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}
			if items == nil {
				items = []storage.Schema{}
			}
			json.NewEncoder(w).Encode(items)
}

// @Summary Create Schema
// @Description Creates a new schema version
// @Tags Schemas
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body createSchemaRequest true "Schema Details"
// @Success 200 {object} map[string]any
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/schemas [post]
func (a *API) handleCreateSchema(w http.ResponseWriter, r *http.Request) {
			appID, err := parseIDParam(r, "id")
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
				return
			}

			var req createSchemaRequest
			if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
				return
			}
			if req.SchemaText == "" {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "schema_text is required"})
				return
			}

			// Validate Cedar schema syntax (JSON format)
			var schemaCheck map[string]any
			if err := json.Unmarshal([]byte(req.SchemaText), &schemaCheck); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid cedar schema JSON: " + err.Error()})
				return
			}

	schemaID, version, err := a.schemas.CreateSchema(r.Context(), appID, req.SchemaText, req.Activate)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}

			// Log schema creation to audit trail
	if a.audits != nil {
				auditCtx := map[string]any{
					"version":   version,
					"activated": req.Activate,
				}
		_ = a.audits.Log(r.Context(), &appID, "api", "schema.create", "", "", auditCtx)
			}

			json.NewEncoder(w).Encode(map[string]any{"schema_id": schemaID, "version": version})
}

// @Summary Get Active Schema
// @Description Returns the currently active schema
// @Tags Schemas
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {object} storage.Schema
// @Failure 404 {object} map[string]string
// @Router /v1/apps/{id}/schemas/active [get]
func (a *API) handleGetActiveSchema(w http.ResponseWriter, r *http.Request) {
			appID, err := parseIDParam(r, "id")
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
				return
			}
	schema, err := a.schemas.GetActiveSchema(r.Context(), appID)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}
			if schema == nil {
				w.WriteHeader(http.StatusNotFound)
				json.NewEncoder(w).Encode(map[string]string{"error": "no active schema"})
				return
			}
			json.NewEncoder(w).Encode(schema)
}

// @Summary Activate Schema
// @Description Sets a specific schema version as active
// @Tags Schemas
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body activateSchemaRequest true "Activation Details"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/schemas/activate [post]
func (a *API) handleActivateSchema(w http.ResponseWriter, r *http.Request) {
			appID, err := parseIDParam(r, "id")
			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
				return
			}

			var req activateSchemaRequest
			if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
				return
			}
			if req.Version <= 0 {
				w.WriteHeader(http.StatusBadRequest)
				json.NewEncoder(w).Encode(map[string]string{"error": "version is required"})
				return
			}

	if err := a.schemas.ActivateSchema(r.Context(), appID, req.Version); err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}

			// Log schema activation to audit trail
	if a.audits != nil {
				auditCtx := map[string]any{
					"version": req.Version,
				}
		_ = a.audits.Log(r.Context(), &appID, "api", "schema.activate", "", "", auditCtx)
			}

			w.WriteHeader(http.StatusNoContent)
}

// @Summary List Permissions
// @Description Calculates effective permissions for a principal
// @Tags Authorization
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param principal_type query string true "Principal Type (e.g. User)"
// @Param principal_id query string true "Principal ID"
// @Success 200 {object} authz.PermissionsResponse
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/permissions [get]
func (a *API) handleListPermissions(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")

		appID, err := parseIDParam(r, "id")
		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
			return
		}

		principalType := r.URL.Query().Get("principal_type")
		principalID := r.URL.Query().Get("principal_id")

		if principalType == "" || principalID == "" {
			w.WriteHeader(http.StatusBadRequest)
			json.NewEncoder(w).Encode(map[string]string{"error": "principal_type and principal_id query parameters are required"})
			return
		}

		// Create permissions service with entity adapter for group memberships
	groupProvider := &entityGroupAdapter{entities: a.entities}
	permSvc := authz.NewPermissionsService(a.policies, groupProvider)

		result, err := permSvc.ListPermissions(r.Context(), appID, principalType, principalID)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
			return
		}

	// Filter out PolicyID unless debug mode is enabled
	debug := r.URL.Query().Get("debug") == "true"
	if !debug && result != nil {
		for i := range result.Permissions {
			result.Permissions[i].PolicyID = ""
		}
	}

		json.NewEncoder(w).Encode(result)
}

// @Summary List Audit Logs
// @Description Returns a list of audit log entries
// @Tags Audit
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param application_id query int false "Filter by Application ID"
// @Param action query string false "Filter by Action"
// @Param decision query string false "Filter by Decision (allow/deny)"
// @Param limit query int false "Max results (default 50)"
// @Param offset query int false "Offset results"
// @Success 200 {object} auditListResponse
// @Failure 500 {object} map[string]string
// @Router /v1/audit [get]
func (a *API) handleListAuditLogs(w http.ResponseWriter, r *http.Request) {
			filter := storage.AuditFilter{
				Limit:  50,
				Offset: 0,
			}

			// Parse query params
			if v := r.URL.Query().Get("application_id"); v != "" {
				if id, err := strconv.ParseInt(v, 10, 64); err == nil {
					filter.ApplicationID = &id
				}
			}
			if v := r.URL.Query().Get("action"); v != "" {
				filter.Action = v
			}
			if v := r.URL.Query().Get("decision"); v != "" {
				filter.Decision = v
			}
			if v := r.URL.Query().Get("limit"); v != "" {
				if n, err := strconv.Atoi(v); err == nil && n > 0 && n <= 200 {
					filter.Limit = n
				}
			}
			if v := r.URL.Query().Get("offset"); v != "" {
				if n, err := strconv.Atoi(v); err == nil && n >= 0 {
					filter.Offset = n
				}
			}

	items, total, err := a.audits.List(r.Context(), filter)
			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
				return
			}
			if items == nil {
				items = []storage.AuditLog{}
			}
			json.NewEncoder(w).Encode(auditListResponse{Items: items, Total: total})
}

func parseIDParam(r *http.Request, key string) (int64, error) {
	val := chi.URLParam(r, key)
	return strconv.ParseInt(val, 10, 64)
}

// entityGroupAdapter adapts storage.EntityRepo to authz.GroupMembershipProvider.
type entityGroupAdapter struct {
	entities *storage.EntityRepo
}

func (a *entityGroupAdapter) GetGroupMemberships(ctx context.Context, applicationID int64, entityType, entityID string) ([]authz.GroupRef, error) {
	parents, err := a.entities.GetGroupMemberships(ctx, applicationID, entityType, entityID)
	if err != nil {
		return nil, err
	}
	result := make([]authz.GroupRef, len(parents))
	for i, p := range parents {
		result[i] = authz.GroupRef{Type: p.Type, ID: p.ID}
	}
	return result, nil
}

// @Summary Get Entitlements for IdP Integration
// @Description Returns all entitlements/permissions for a user and their groups within an application.
// @Description This endpoint is designed for Identity Provider (IdP) integration, allowing external
// @Description systems to query what a user can do based on their identity and group memberships.
// @Tags Entitlements
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body entitlementsRequest true "Entitlements Request"
// @Success 200 {object} entitlementsResponse
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /v1/entitlements [post]
func (a *API) handleGetEntitlements(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	var req entitlementsRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request body"})
		return
	}

	// Validate required fields
	if req.Username == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "username is required"})
		return
	}

	// Resolve application ID
	var appID int64
	var appName string
	if req.ApplicationID > 0 {
		appID = req.ApplicationID
		// Get app name
		apps, err := a.apps.List(r.Context())
		if err == nil {
			for _, app := range apps {
				if app.ID == appID {
					appName = app.Name
					break
				}
			}
		}
	} else if req.ApplicationName != "" {
		// Lookup by name
		apps, err := a.apps.List(r.Context())
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": "failed to lookup application"})
			return
		}
		for _, app := range apps {
			if app.Name == req.ApplicationName {
				appID = app.ID
				appName = app.Name
				break
			}
		}
		if appID == 0 {
			w.WriteHeader(http.StatusNotFound)
			json.NewEncoder(w).Encode(map[string]string{"error": "application not found"})
			return
		}
	} else {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "application_id or application_name is required"})
		return
	}

	// Create permissions service
	groupProvider := &entityGroupAdapter{entities: a.entities}
	permSvc := authz.NewPermissionsService(a.policies, groupProvider)

	// Get user's direct entitlements
	userResult, err := permSvc.ListPermissions(r.Context(), appID, "User", req.Username)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Convert to entitlement entries
	userEntitlements := make([]entitlementEntry, 0)
	if userResult != nil {
		for _, p := range userResult.Permissions {
			userEntitlements = append(userEntitlements, entitlementEntry{
				Effect:        p.Effect,
				Actions:       p.Actions,
				ResourceTypes: p.ResourceTypes,
				ResourceIDs:   p.ResourceIDs,
				Conditions:    p.Conditions,
			})
		}
	}

	// Get group entitlements if groups are provided
	groupEntitlements := make(map[string][]entitlementEntry)
	if req.IncludeInherited && len(req.Groups) > 0 {
		for _, groupID := range req.Groups {
			groupResult, err := permSvc.ListPermissions(r.Context(), appID, "Group", groupID)
			if err != nil {
				continue // Skip groups that fail
			}
			if groupResult != nil && len(groupResult.Permissions) > 0 {
				entries := make([]entitlementEntry, len(groupResult.Permissions))
				for i, p := range groupResult.Permissions {
					entries[i] = entitlementEntry{
						Effect:        p.Effect,
						Actions:       p.Actions,
						ResourceTypes: p.ResourceTypes,
						ResourceIDs:   p.ResourceIDs,
						Conditions:    p.Conditions,
					}
				}
				groupEntitlements[groupID] = entries
			}
		}
	}

	// Build response
	resp := entitlementsResponse{
		Username:        req.Username,
		ApplicationID:   appID,
		ApplicationName: appName,
		Entitlements:    userEntitlements,
	}
	if len(groupEntitlements) > 0 {
		resp.GroupEntitlements = groupEntitlements
	}

	json.NewEncoder(w).Encode(resp)
}

// @Summary Get Entra Integration Status
// @Description Returns whether Entra ID integration is configured and available
// @Tags Entra
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {object} map[string]interface{}
// @Router /v1/entra/status [get]
func (a *API) handleEntraStatus(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	configured := a.entraClient != nil && a.entraClient.IsConfigured()

	// Get tenant_id from the appropriate source
	tenantID := a.cfg.AzureTenantID
	if a.settings != nil {
		if dbConfig, err := a.settings.GetEntraConfig(r.Context()); err == nil && dbConfig.Configured {
			tenantID = dbConfig.TenantID
		}
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"configured": configured,
		"tenant_id":  tenantID,
	})
}

// @Summary Search Entra Users
// @Description Search for users in Microsoft Entra ID (Azure AD)
// @Tags Entra
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param q query string false "Search query (name, email, or UPN prefix)"
// @Param limit query int false "Max results (default 25, max 50)"
// @Success 200 {object} entra.SearchUsersResult
// @Failure 400 {object} map[string]string
// @Failure 503 {object} map[string]string
// @Router /v1/entra/users [get]
func (a *API) handleEntraSearchUsers(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if a.entraClient == nil || !a.entraClient.IsConfigured() {
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(map[string]string{"error": "Entra integration not configured"})
		return
	}

	query := r.URL.Query().Get("q")
	limit := 25
	if l := r.URL.Query().Get("limit"); l != "" {
		if n, err := strconv.Atoi(l); err == nil && n > 0 {
			limit = n
		}
	}

	result, err := a.entraClient.SearchUsers(r.Context(), query, limit)
	if err != nil {
		w.WriteHeader(http.StatusBadGateway)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	json.NewEncoder(w).Encode(result)
}

// @Summary Get Entra User
// @Description Get a specific user from Microsoft Entra ID by ID or UPN
// @Tags Entra
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path string true "User ID or User Principal Name"
// @Success 200 {object} entra.User
// @Failure 404 {object} map[string]string
// @Failure 503 {object} map[string]string
// @Router /v1/entra/users/{id} [get]
func (a *API) handleEntraGetUser(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if a.entraClient == nil || !a.entraClient.IsConfigured() {
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(map[string]string{"error": "Entra integration not configured"})
		return
	}

	userID := chi.URLParam(r, "id")

	user, err := a.entraClient.GetUser(r.Context(), userID)
	if err != nil {
		if err.Error() == "user not found" {
			w.WriteHeader(http.StatusNotFound)
		} else {
			w.WriteHeader(http.StatusBadGateway)
		}
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	json.NewEncoder(w).Encode(user)
}

// @Summary Search Entra Groups
// @Description Search for groups in Microsoft Entra ID (Azure AD)
// @Tags Entra
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param q query string false "Search query (group name prefix)"
// @Param limit query int false "Max results (default 25, max 50)"
// @Success 200 {object} entra.SearchGroupsResult
// @Failure 400 {object} map[string]string
// @Failure 503 {object} map[string]string
// @Router /v1/entra/groups [get]
func (a *API) handleEntraSearchGroups(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if a.entraClient == nil || !a.entraClient.IsConfigured() {
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(map[string]string{"error": "Entra integration not configured"})
		return
	}

	query := r.URL.Query().Get("q")
	limit := 25
	if l := r.URL.Query().Get("limit"); l != "" {
		if n, err := strconv.Atoi(l); err == nil && n > 0 {
			limit = n
		}
	}

	result, err := a.entraClient.SearchGroups(r.Context(), query, limit)
	if err != nil {
		w.WriteHeader(http.StatusBadGateway)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	json.NewEncoder(w).Encode(result)
}

// @Summary Get Entra Group
// @Description Get a specific group from Microsoft Entra ID by ID
// @Tags Entra
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path string true "Group ID"
// @Success 200 {object} entra.Group
// @Failure 404 {object} map[string]string
// @Failure 503 {object} map[string]string
// @Router /v1/entra/groups/{id} [get]
func (a *API) handleEntraGetGroup(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if a.entraClient == nil || !a.entraClient.IsConfigured() {
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(map[string]string{"error": "Entra integration not configured"})
		return
	}

	groupID := chi.URLParam(r, "id")

	group, err := a.entraClient.GetGroup(r.Context(), groupID)
	if err != nil {
		if err.Error() == "group not found" {
			w.WriteHeader(http.StatusNotFound)
		} else {
			w.WriteHeader(http.StatusBadGateway)
		}
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	json.NewEncoder(w).Encode(group)
}

// entraSettingsRequest is the request body for saving Entra settings.
type entraSettingsRequest struct {
	TenantID     string `json:"tenant_id"`
	ClientID     string `json:"client_id"`
	ClientSecret string `json:"client_secret"`
	RedirectURI  string `json:"redirect_uri"`
	AuthEnabled  bool   `json:"auth_enabled"`
}

// entraSettingsResponse is the response for getting Entra settings.
type entraSettingsResponse struct {
	TenantID          string `json:"tenant_id"`
	ClientID          string `json:"client_id"`
	HasClientSecret   bool   `json:"has_client_secret"`
	RedirectURI       string `json:"redirect_uri"`
	AuthEnabled       bool   `json:"auth_enabled"`
	Configured        bool   `json:"configured"`
	ConfiguredFromEnv bool   `json:"configured_from_env"`
}

// entraAuthConfigResponse is the public auth configuration for the frontend (no secrets).
type entraAuthConfigResponse struct {
	Enabled     bool   `json:"enabled"`
	TenantID    string `json:"tenant_id,omitempty"`
	ClientID    string `json:"client_id,omitempty"`
	RedirectURI string `json:"redirect_uri,omitempty"`
	Authority   string `json:"authority,omitempty"`
}

// @Summary Get Entra Settings
// @Description Returns the current Entra ID configuration (without secrets)
// @Tags Settings
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {object} entraSettingsResponse
// @Router /v1/settings/entra [get]
func (a *API) handleGetEntraSettings(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Check if configured from environment first
	envConfigured := a.cfg.AzureTenantID != "" && a.cfg.AzureClientID != "" && a.cfg.AzureClientSecret != ""

	if envConfigured {
		json.NewEncoder(w).Encode(entraSettingsResponse{
			TenantID:          a.cfg.AzureTenantID,
			ClientID:          a.cfg.AzureClientID,
			HasClientSecret:   true,
			Configured:        true,
			ConfiguredFromEnv: true,
		})
		return
	}

	// Check database settings
	if a.settings == nil {
		json.NewEncoder(w).Encode(entraSettingsResponse{
			Configured:        false,
			ConfiguredFromEnv: false,
		})
		return
	}

	config, err := a.settings.GetEntraConfig(r.Context())
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	json.NewEncoder(w).Encode(entraSettingsResponse{
		TenantID:          config.TenantID,
		ClientID:          config.ClientID,
		HasClientSecret:   config.ClientSecret != "",
		RedirectURI:       config.RedirectURI,
		AuthEnabled:       config.AuthEnabled,
		Configured:        config.Configured,
		ConfiguredFromEnv: false,
	})
}

// @Summary Get Auth Configuration
// @Description Returns the authentication configuration for the frontend (public endpoint, no secrets)
// @Tags Auth
// @Produce json
// @Success 200 {object} entraAuthConfigResponse
// @Router /v1/auth/config [get]
func (a *API) handleGetAuthConfig(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	// Default response - no Entra auth
	response := entraAuthConfigResponse{
		Enabled: false,
	}

	// Check database settings first
	if a.settings != nil {
		config, err := a.settings.GetEntraConfig(r.Context())
		if err == nil && config.Configured && config.AuthEnabled {
			response = entraAuthConfigResponse{
				Enabled:     true,
				TenantID:    config.TenantID,
				ClientID:    config.ClientID,
				RedirectURI: config.RedirectURI,
				Authority:   fmt.Sprintf("https://login.microsoftonline.com/%s", config.TenantID),
			}
		}
	}

	json.NewEncoder(w).Encode(response)
}

// @Summary Save Entra Settings
// @Description Saves the Entra ID configuration
// @Tags Settings
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body entraSettingsRequest true "Entra Settings"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Router /v1/settings/entra [post]
func (a *API) handleSaveEntraSettings(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if a.settings == nil {
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(map[string]string{"error": "Settings storage not available"})
		return
	}

	var req entraSettingsRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "Invalid request body"})
		return
	}

	// Validate required fields
	if req.TenantID == "" || req.ClientID == "" || req.ClientSecret == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "tenant_id, client_id, and client_secret are required"})
		return
	}

	// Get user for audit
	user := GetUserFromContext(r.Context())
	updatedBy := "unknown"
	if user != nil {
		updatedBy = user.ID
	}

	// Save settings
	config := &storage.EntraConfig{
		TenantID:     req.TenantID,
		ClientID:     req.ClientID,
		ClientSecret: req.ClientSecret,
		RedirectURI:  req.RedirectURI,
		AuthEnabled:  req.AuthEnabled,
	}

	if err := a.settings.SetEntraConfig(r.Context(), config, updatedBy); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Update the Entra client with new credentials
	a.entraClient = entra.NewClient(req.TenantID, req.ClientID, req.ClientSecret)

	// Audit log
	if a.audits != nil {
		_ = a.audits.Log(r.Context(), nil, updatedBy, "settings.entra.update", "entra", "", nil)
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "saved"})
}

// @Summary Test Entra Connection
// @Description Tests the Entra ID connection with provided or saved credentials
// @Tags Settings
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body entraSettingsRequest false "Entra Settings (optional, uses saved if not provided)"
// @Success 200 {object} map[string]interface{}
// @Failure 400 {object} map[string]string
// @Router /v1/settings/entra/test [post]
func (a *API) handleTestEntraConnection(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	var req entraSettingsRequest
	_ = json.NewDecoder(r.Body).Decode(&req)

	// Use provided credentials or fall back to saved/env
	tenantID := req.TenantID
	clientID := req.ClientID
	clientSecret := req.ClientSecret

	if tenantID == "" || clientID == "" || clientSecret == "" {
		// Try to use existing credentials
		if a.cfg.AzureTenantID != "" {
			tenantID = a.cfg.AzureTenantID
			clientID = a.cfg.AzureClientID
			clientSecret = a.cfg.AzureClientSecret
		} else if a.settings != nil {
			config, _ := a.settings.GetEntraConfig(r.Context())
			if config != nil && config.Configured {
				tenantID = config.TenantID
				clientID = config.ClientID
				clientSecret = config.ClientSecret
			}
		}
	}

	if tenantID == "" || clientID == "" || clientSecret == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "No credentials provided or configured"})
		return
	}

	// Create temporary client to test
	testClient := entra.NewClient(tenantID, clientID, clientSecret)

	// Try to search for users (this will test the connection)
	result, err := testClient.SearchUsers(r.Context(), "", 1)
	if err != nil {
		w.WriteHeader(http.StatusBadGateway)
		json.NewEncoder(w).Encode(map[string]interface{}{
			"success": false,
			"error":   err.Error(),
		})
		return
	}

	json.NewEncoder(w).Encode(map[string]interface{}{
		"success":     true,
		"message":     "Successfully connected to Microsoft Graph API",
		"users_found": result.TotalCount,
	})
}

// @Summary Delete Entra Settings
// @Description Removes the Entra ID configuration from the database
// @Tags Settings
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {object} map[string]string
// @Router /v1/settings/entra [delete]
func (a *API) handleDeleteEntraSettings(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	if a.settings == nil {
		w.WriteHeader(http.StatusServiceUnavailable)
		json.NewEncoder(w).Encode(map[string]string{"error": "Settings storage not available"})
		return
	}

	// Get user for audit
	user := GetUserFromContext(r.Context())
	updatedBy := "unknown"
	if user != nil {
		updatedBy = user.ID
	}

	if err := a.settings.DeleteEntraConfig(r.Context()); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Reset Entra client to use env config
	a.entraClient = entra.NewClient(a.cfg.AzureTenantID, a.cfg.AzureClientID, a.cfg.AzureClientSecret)

	// Audit log
	if a.audits != nil {
		_ = a.audits.Log(r.Context(), nil, updatedBy, "settings.entra.delete", "entra", "", nil)
	}

	json.NewEncoder(w).Encode(map[string]string{"status": "deleted"})
}
