package httpserver

import (
	"context"
	"encoding/json"
	"net/http"
	"runtime/debug"
	"strconv"
	"time"

	cedar "github.com/cedar-policy/cedar-go"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	httpSwagger "github.com/swaggo/http-swagger"

	_ "cedar/docs" // Docs generated by Swag CLI
	"cedar/internal/authz"
	"cedar/internal/config"
	"cedar/internal/storage"
)

type CacheInvalidator interface {
	InvalidateApp(ctx context.Context, appID int64) error
}

type healthResponse struct {
	Status       string `json:"status"`
	CedarVersion string `json:"cedar_version,omitempty"`
}

type authorizeRequest struct {
	ApplicationID int64           `json:"application_id"`
	Principal     entityReference `json:"principal"`
	Action        entityReference `json:"action"`
	Resource      entityReference `json:"resource"`
	Context       map[string]any  `json:"context,omitempty"`
}

type entityReference struct {
	Type string `json:"type"`
	ID   string `json:"id"`
}

type authorizeResponse struct {
	Decision string   `json:"decision"`
	Reasons  []string `json:"reasons"`
	Errors   []string `json:"errors"`
}

type createAppRequest struct {
	Name        string `json:"name"`
	NamespaceID int64  `json:"namespace_id"`
	Description string `json:"description"`
}

type createNamespaceRequest struct {
	Name        string `json:"name"`
	Description string `json:"description"`
}

type createPolicyRequest struct {
	Name        string `json:"name"`
	Description string `json:"description"`
	PolicyText  string `json:"policy_text"`
	Activate    bool   `json:"activate"`
}

type upsertEntityRequest struct {
	Type       string              `json:"type"`
	ID         string              `json:"id"`
	Attributes json.RawMessage     `json:"attributes" swaggertype:"object"`
	Parents    []storage.ParentRef `json:"parents"`
}

type createSchemaRequest struct {
	SchemaText string `json:"schema_text"`
	Activate   bool   `json:"activate"`
}

type activateSchemaRequest struct {
	Version int `json:"version"`
}

type auditListResponse struct {
	Items []storage.AuditLog `json:"items"`
	Total int                `json:"total"`
}

// AuditLogger is used to record audit events.
type AuditLogger interface {
	Log(ctx context.Context, applicationID *int64, actor, action, target, decision string, auditContext map[string]any) error
}

// SchemaProvider is used to validate policies against schemas.
type SchemaProvider interface {
	GetActiveSchema(ctx context.Context, applicationID int64) (*storage.Schema, error)
}

// API provides the HTTP handlers for the application.
type API struct {
	cfg        config.Config
	authzSvc   *authz.Service
	apps       *storage.ApplicationRepo
	policies   *storage.PolicyRepo
	entities   *storage.EntityRepo
	schemas    *storage.SchemaRepo
	audits     *storage.AuditRepo
	namespaces *storage.NamespaceRepo
	cache      CacheInvalidator
}

// NewRouter configures the HTTP router with basic endpoints.
// @title Enterprise Policy Management API
// @version 1.0
// @description API for managing Cedar policies, entities, and performing authorization checks.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.email support@example.com
// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html
// @host localhost:8080
// @BasePath /
// @schemes http https
// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name X-API-Key
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func NewRouter(cfg config.Config, authzSvc *authz.Service, apps *storage.ApplicationRepo, policies *storage.PolicyRepo, entities *storage.EntityRepo, schemas *storage.SchemaRepo, audits *storage.AuditRepo, namespaces *storage.NamespaceRepo, cache CacheInvalidator) http.Handler {
	api := &API{
		cfg:        cfg,
		authzSvc:   authzSvc,
		apps:       apps,
		policies:   policies,
		entities:   entities,
		schemas:    schemas,
		audits:     audits,
		namespaces: namespaces,
		cache:      cache,
	}

	r := chi.NewRouter()
	r.Use(corsMiddleware(cfg))
	r.Use(middleware.RequestID)
	r.Use(middleware.RealIP)
	r.Use(middleware.Recoverer)
	r.Use(middleware.Timeout(60 * time.Second))

	// Initialize auth middleware
	authMiddleware, err := NewAuthMiddleware(cfg)
	if err != nil {
		panic("failed to create auth middleware: " + err.Error())
	}
	r.Use(authMiddleware.Middleware)

	// Initialize rate limiter (must be after auth middleware to access user context)
	if rateLimiter := NewRateLimiter(cfg); rateLimiter != nil {
		r.Use(rateLimiter)
	}

	r.Get("/health", api.handleHealth)
	r.Get("/v1/me", api.handleGetMe)
	r.Post("/v1/authorize", api.handleAuthorize)

	r.Route("/v1/apps", func(r chi.Router) {
		r.Get("/", api.handleListApps)
		r.Post("/", api.handleCreateApp)
	})

	r.Route("/v1/namespaces", func(r chi.Router) {
		r.Get("/", api.handleListNamespaces)
		r.Post("/", api.handleCreateNamespace)
	})

	r.Post("/v1/apps/{id}/policies", api.handleCreatePolicy)
	r.Get("/v1/apps/{id}/policies", api.handleListPolicies)
	r.Get("/v1/apps/{id}/policies/{policyId}", api.handleGetPolicy)

	r.Post("/v1/apps/{id}/entities", api.handleUpsertEntity)
	r.Get("/v1/apps/{id}/entities", api.handleListEntities)

	r.Route("/v1/apps/{id}/schemas", func(r chi.Router) {
		r.Get("/", api.handleListSchemas)
		r.Post("/", api.handleCreateSchema)
		r.Get("/active", api.handleGetActiveSchema)
		r.Post("/activate", api.handleActivateSchema)
	})

	r.Get("/v1/apps/{id}/permissions", api.handleListPermissions)

	r.Route("/v1/audit", func(r chi.Router) {
		r.Get("/", api.handleListAuditLogs)
	})

	// Swagger UI
	r.Get("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // The url pointing to API definition
	))

	return r
}

// @Summary Health Check
// @Description Checks if the service is running
// @Tags System
// @Produce json
// @Success 200 {object} healthResponse
// @Router /health [get]
func (a *API) handleHealth(w http.ResponseWriter, _ *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	version := "unknown"
	if info, ok := debug.ReadBuildInfo(); ok {
		for _, dep := range info.Deps {
			if dep.Path == "github.com/cedar-policy/cedar-go" {
				version = dep.Version
				break
			}
		}
	}

	_ = json.NewEncoder(w).Encode(healthResponse{
		Status:       "ok",
		CedarVersion: version,
	})
}

// @Summary Get Current User
// @Description Returns the currently authenticated user
// @Tags System
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {object} UserContext
// @Failure 401 {object} map[string]string
// @Router /v1/me [get]
func (a *API) handleGetMe(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	user := GetUserFromContext(r.Context())
	if user == nil {
		w.WriteHeader(http.StatusUnauthorized)
		_ = json.NewEncoder(w).Encode(map[string]string{"error": "not authenticated"})
		return
	}
	_ = json.NewEncoder(w).Encode(user)
}

// @Summary Evaluate Authorization
// @Description Performs a Cedar authorization check
// @Tags Authorization
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body authorizeRequest true "Authorization Request"
// @Success 200 {object} authorizeResponse
// @Failure 400 {object} map[string]string
// @Router /v1/authorize [post]
func (a *API) handleAuthorize(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	var req authorizeRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}

	if req.ApplicationID == 0 || req.Principal.Type == "" || req.Action.Type == "" || req.Resource.Type == "" || req.Principal.ID == "" || req.Action.ID == "" || req.Resource.ID == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "application_id, principal, action, and resource are required"})
		return
	}

	// Prepare context with cache source tracker
	var cacheSource string = "DB" // Default if not updated
	ctx := context.WithValue(r.Context(), storage.CtxKeyCacheSource, &cacheSource)

	result, err := a.authzSvc.Evaluate(ctx, authz.EvaluateInput{
		ApplicationID: req.ApplicationID,
		Principal:     authz.Reference{Type: req.Principal.Type, ID: req.Principal.ID},
		Action:        authz.Reference{Type: req.Action.Type, ID: req.Action.ID},
		Resource:      authz.Reference{Type: req.Resource.Type, ID: req.Resource.ID},
		Context:       req.Context,
	})
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Set response header to indicate cache source (L1, L2, or DB)
	w.Header().Set("X-Cedar-Cache", cacheSource)

	// Log authorization decision to audit trail
	if a.audits != nil {
		appID := req.ApplicationID
		principal := req.Principal.Type + "::" + req.Principal.ID
		action := req.Action.Type + "::" + req.Action.ID
		resource := req.Resource.Type + "::" + req.Resource.ID

		// Get the authenticated caller (service/user making the request)
		caller := "unknown"
		if user := GetUserFromContext(r.Context()); user != nil {
			caller = user.ID
		}

		auditCtx := map[string]any{
			"caller":    caller,    // Authenticated service/user making the request
			"principal": principal, // Subject of the authorization check
			"action":    action,
			"resource":  resource,
			"reasons":   result.Reasons,
			"errors":    result.Errors,
		}
		if req.Context != nil {
			auditCtx["request_context"] = req.Context
		}
		// Actor is the authenticated caller, not the principal being checked
		_ = a.audits.Log(r.Context(), &appID, caller, "authorize", resource, result.Decision, auditCtx)
	}

	w.WriteHeader(http.StatusOK)
	json.NewEncoder(w).Encode(authorizeResponse{
		Decision: result.Decision,
		Reasons:  result.Reasons,
		Errors:   result.Errors,
	})
}

// @Summary List Applications
// @Description Returns a list of all registered applications
// @Tags Applications
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {array} storage.Application
// @Failure 500 {object} map[string]string
// @Router /v1/apps [get]
func (a *API) handleListApps(w http.ResponseWriter, r *http.Request) {
	appsList, err := a.apps.List(r.Context())
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	json.NewEncoder(w).Encode(appsList)
}

// @Summary Create Application
// @Description Registers a new application
// @Tags Applications
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body createAppRequest true "Application Details"
// @Success 200 {object} map[string]int64
// @Failure 400 {object} map[string]string
// @Router /v1/apps [post]
func (a *API) handleCreateApp(w http.ResponseWriter, r *http.Request) {
	var req createAppRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}
	if req.Name == "" || req.NamespaceID == 0 {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "name and namespace_id are required"})
		return
	}

	id, err := a.apps.Create(r.Context(), req.Name, req.NamespaceID, req.Description)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Log application creation to audit trail
	if a.audits != nil {
		auditCtx := map[string]any{
			"name":         req.Name,
			"namespace_id": req.NamespaceID,
			"description":  req.Description,
		}
		_ = a.audits.Log(r.Context(), &id, "api", "application.create", req.Name, "", auditCtx)
	}

	json.NewEncoder(w).Encode(map[string]any{"id": id})
}

// @Summary List Namespaces
// @Description Returns a list of all namespaces
// @Tags Namespaces
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Success 200 {array} storage.Namespace
// @Failure 500 {object} map[string]string
// @Router /v1/namespaces [get]
func (a *API) handleListNamespaces(w http.ResponseWriter, r *http.Request) {
	list, err := a.namespaces.List(r.Context())
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	if list == nil {
		list = []storage.Namespace{}
	}
	json.NewEncoder(w).Encode(list)
}

// @Summary Create Namespace
// @Description Creates a new namespace
// @Tags Namespaces
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param request body createNamespaceRequest true "Namespace Details"
// @Success 200 {object} map[string]int64
// @Failure 400 {object} map[string]string
// @Router /v1/namespaces [post]
func (a *API) handleCreateNamespace(w http.ResponseWriter, r *http.Request) {
	var req createNamespaceRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}
	if req.Name == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "name is required"})
		return
	}

	id, err := a.namespaces.Create(r.Context(), req.Name, req.Description)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Log namespace creation to audit trail
	if a.audits != nil {
		auditCtx := map[string]any{
			"name":        req.Name,
			"description": req.Description,
		}
		_ = a.audits.Log(r.Context(), nil, "api", "namespace.create", req.Name, "", auditCtx)
	}

	json.NewEncoder(w).Encode(map[string]any{"id": id})
}

// @Summary Create/Update Policy
// @Description Creates a new policy version or updates an existing one
// @Tags Policies
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body createPolicyRequest true "Policy Details"
// @Success 200 {object} map[string]any
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/policies [post]
func (a *API) handleCreatePolicy(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}

	var req createPolicyRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}
	if req.Name == "" || req.PolicyText == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "name and policy_text are required"})
		return
	}

	// Validate Cedar syntax early.
	var tmpPolicy cedar.Policy
	if err := tmpPolicy.UnmarshalCedar([]byte(req.PolicyText)); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid cedar policy syntax: " + err.Error()})
		return
	}

	// Check if schema exists for information purposes
	var hasActiveSchema bool
	if a.schemas != nil {
		activeSchema, err := a.schemas.GetActiveSchema(r.Context(), appID)
		if err != nil {
			w.WriteHeader(http.StatusInternalServerError)
			json.NewEncoder(w).Encode(map[string]string{"error": "failed to check schema: " + err.Error()})
			return
		}
		hasActiveSchema = activeSchema != nil
	}
	_ = hasActiveSchema

	policyID, version, err := a.policies.UpsertPolicyWithVersion(r.Context(), appID, req.Name, req.Description, req.PolicyText, req.Activate)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	if a.cache != nil {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Log policy creation/update to audit trail
	if a.audits != nil {
		auditAction := "policy.create"
		auditCtx := map[string]any{
			"policy_name": req.Name,
			"version":     version,
			"activated":   req.Activate,
		}
		_ = a.audits.Log(r.Context(), &appID, "api", auditAction, req.Name, "", auditCtx)
	}

	json.NewEncoder(w).Encode(map[string]any{"policy_id": policyID, "version": version})
}

// @Summary List Policies
// @Description Returns a list of policies for an application
// @Tags Policies
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {array} storage.PolicySummary
// @Failure 500 {object} map[string]string
// @Router /v1/apps/{id}/policies [get]
func (a *API) handleListPolicies(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}

	items, err := a.policies.ListPolicies(r.Context(), appID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	json.NewEncoder(w).Encode(items)
}

// @Summary Get Policy Details
// @Description Returns details of a specific policy
// @Tags Policies
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param policyId path int true "Policy ID"
// @Success 200 {object} storage.PolicyDetails
// @Failure 404 {object} map[string]string
// @Router /v1/apps/{id}/policies/{policyId} [get]
func (a *API) handleGetPolicy(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}
	policyID, err := parseIDParam(r, "policyId")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid policy id"})
		return
	}

	item, err := a.policies.GetPolicy(r.Context(), appID, policyID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	json.NewEncoder(w).Encode(item)
}

// @Summary Upsert Entity
// @Description Creates or updates an entity
// @Tags Entities
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body upsertEntityRequest true "Entity Details"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/entities [post]
func (a *API) handleUpsertEntity(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}

	var req upsertEntityRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}
	if req.Type == "" || req.ID == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "type and id are required"})
		return
	}

	if err := a.entities.UpsertEntity(r.Context(), appID, req.Type, req.ID, req.Attributes, req.Parents); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	if a.cache != nil {
		_ = a.cache.InvalidateApp(r.Context(), appID)
	}

	// Log entity upsert to audit trail
	if a.audits != nil {
		entityRef := req.Type + "::" + req.ID
		auditCtx := map[string]any{
			"entity_type": req.Type,
			"entity_id":   req.ID,
		}
		if len(req.Parents) > 0 {
			auditCtx["parents"] = req.Parents
		}
		_ = a.audits.Log(r.Context(), &appID, "api", "entity.upsert", entityRef, "", auditCtx)
	}

	w.WriteHeader(http.StatusNoContent)
}

// @Summary List Entities
// @Description Returns a list of entities for an application
// @Tags Entities
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {object} map[string]interface{}
// @Failure 500 {object} map[string]string
// @Router /v1/apps/{id}/entities [get]
func (a *API) handleListEntities(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}
	entitiesMap, err := a.entities.Entities(r.Context(), appID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	json.NewEncoder(w).Encode(entitiesMap)
}

// @Summary List Schemas
// @Description Returns a list of schema versions
// @Tags Schemas
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {array} storage.Schema
// @Failure 500 {object} map[string]string
// @Router /v1/apps/{id}/schemas [get]
func (a *API) handleListSchemas(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}
	items, err := a.schemas.ListSchemas(r.Context(), appID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	if items == nil {
		items = []storage.Schema{}
	}
	json.NewEncoder(w).Encode(items)
}

// @Summary Create Schema
// @Description Creates a new schema version
// @Tags Schemas
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body createSchemaRequest true "Schema Details"
// @Success 200 {object} map[string]any
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/schemas [post]
func (a *API) handleCreateSchema(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}

	var req createSchemaRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}
	if req.SchemaText == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "schema_text is required"})
		return
	}

	// Validate Cedar schema syntax (JSON format)
	var schemaCheck map[string]any
	if err := json.Unmarshal([]byte(req.SchemaText), &schemaCheck); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid cedar schema JSON: " + err.Error()})
		return
	}

	schemaID, version, err := a.schemas.CreateSchema(r.Context(), appID, req.SchemaText, req.Activate)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Log schema creation to audit trail
	if a.audits != nil {
		auditCtx := map[string]any{
			"version":   version,
			"activated": req.Activate,
		}
		_ = a.audits.Log(r.Context(), &appID, "api", "schema.create", "", "", auditCtx)
	}

	json.NewEncoder(w).Encode(map[string]any{"schema_id": schemaID, "version": version})
}

// @Summary Get Active Schema
// @Description Returns the currently active schema
// @Tags Schemas
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Success 200 {object} storage.Schema
// @Failure 404 {object} map[string]string
// @Router /v1/apps/{id}/schemas/active [get]
func (a *API) handleGetActiveSchema(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}
	schema, err := a.schemas.GetActiveSchema(r.Context(), appID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	if schema == nil {
		w.WriteHeader(http.StatusNotFound)
		json.NewEncoder(w).Encode(map[string]string{"error": "no active schema"})
		return
	}
	json.NewEncoder(w).Encode(schema)
}

// @Summary Activate Schema
// @Description Sets a specific schema version as active
// @Tags Schemas
// @Accept json
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param request body activateSchemaRequest true "Activation Details"
// @Success 204 "No Content"
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/schemas/activate [post]
func (a *API) handleActivateSchema(w http.ResponseWriter, r *http.Request) {
	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}

	var req activateSchemaRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid request payload"})
		return
	}
	if req.Version <= 0 {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "version is required"})
		return
	}

	if err := a.schemas.ActivateSchema(r.Context(), appID, req.Version); err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	// Log schema activation to audit trail
	if a.audits != nil {
		auditCtx := map[string]any{
			"version": req.Version,
		}
		_ = a.audits.Log(r.Context(), &appID, "api", "schema.activate", "", "", auditCtx)
	}

	w.WriteHeader(http.StatusNoContent)
}

// @Summary List Permissions
// @Description Calculates effective permissions for a principal
// @Tags Authorization
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param id path int true "Application ID"
// @Param principal_type query string true "Principal Type (e.g. User)"
// @Param principal_id query string true "Principal ID"
// @Success 200 {object} authz.PermissionsResponse
// @Failure 400 {object} map[string]string
// @Router /v1/apps/{id}/permissions [get]
func (a *API) handleListPermissions(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")

	appID, err := parseIDParam(r, "id")
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid app id"})
		return
	}

	principalType := r.URL.Query().Get("principal_type")
	principalID := r.URL.Query().Get("principal_id")

	if principalType == "" || principalID == "" {
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "principal_type and principal_id query parameters are required"})
		return
	}

	// Create permissions service with entity adapter for group memberships
	groupProvider := &entityGroupAdapter{entities: a.entities}
	permSvc := authz.NewPermissionsService(a.policies, groupProvider)

	result, err := permSvc.ListPermissions(r.Context(), appID, principalType, principalID)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}

	json.NewEncoder(w).Encode(result)
}

// @Summary List Audit Logs
// @Description Returns a list of audit log entries
// @Tags Audit
// @Produce json
// @Security ApiKeyAuth
// @Security BearerAuth
// @Param application_id query int false "Filter by Application ID"
// @Param action query string false "Filter by Action"
// @Param decision query string false "Filter by Decision (allow/deny)"
// @Param limit query int false "Max results (default 50)"
// @Param offset query int false "Offset results"
// @Success 200 {object} auditListResponse
// @Failure 500 {object} map[string]string
// @Router /v1/audit [get]
func (a *API) handleListAuditLogs(w http.ResponseWriter, r *http.Request) {
	filter := storage.AuditFilter{
		Limit:  50,
		Offset: 0,
	}

	// Parse query params
	if v := r.URL.Query().Get("application_id"); v != "" {
		if id, err := strconv.ParseInt(v, 10, 64); err == nil {
			filter.ApplicationID = &id
		}
	}
	if v := r.URL.Query().Get("action"); v != "" {
		filter.Action = v
	}
	if v := r.URL.Query().Get("decision"); v != "" {
		filter.Decision = v
	}
	if v := r.URL.Query().Get("limit"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n > 0 && n <= 200 {
			filter.Limit = n
		}
	}
	if v := r.URL.Query().Get("offset"); v != "" {
		if n, err := strconv.Atoi(v); err == nil && n >= 0 {
			filter.Offset = n
		}
	}

	items, total, err := a.audits.List(r.Context(), filter)
	if err != nil {
		w.WriteHeader(http.StatusInternalServerError)
		json.NewEncoder(w).Encode(map[string]string{"error": err.Error()})
		return
	}
	if items == nil {
		items = []storage.AuditLog{}
	}
	json.NewEncoder(w).Encode(auditListResponse{Items: items, Total: total})
}

func parseIDParam(r *http.Request, key string) (int64, error) {
	val := chi.URLParam(r, key)
	return strconv.ParseInt(val, 10, 64)
}

// entityGroupAdapter adapts storage.EntityRepo to authz.GroupMembershipProvider.
type entityGroupAdapter struct {
	entities *storage.EntityRepo
}

func (a *entityGroupAdapter) GetGroupMemberships(ctx context.Context, applicationID int64, entityType, entityID string) ([]authz.GroupRef, error) {
	parents, err := a.entities.GetGroupMemberships(ctx, applicationID, entityType, entityID)
	if err != nil {
		return nil, err
	}
	result := make([]authz.GroupRef, len(parents))
	for i, p := range parents {
		result[i] = authz.GroupRef{Type: p.Type, ID: p.ID}
	}
	return result, nil
}
